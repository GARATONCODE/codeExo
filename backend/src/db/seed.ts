import "dotenv/config";
import { db } from "./index.js";
import { exercises } from "./schema.js";
import { logger } from "../lib/logger.js";

const exerciseData = [
  // === BASICS (1-10) ===
  {
    slug: "hello-world",
    title: "Hello World",
    description: "Écrivez une fonction qui retourne la chaîne \"Hello, World!\".\n\nC'est le premier exercice classique pour apprendre un nouveau langage.",
    difficulty: "easy",
    orderIndex: 1,
    tags: ["basics", "strings"],
    templateC: '#include <stdio.h>\n#include <string.h>\n\n// Retourne "Hello, World!" dans le buffer dest\nvoid hello_world(char *dest) {\n    // Votre code ici\n}',
    templatePython: 'def hello_world() -> str:\n    """Retourne \'Hello, World!\'"""\n    # Votre code ici\n    pass',
    templateTypescript: '// Retourne "Hello, World!"\nexport function helloWorld(): string {\n  // Votre code ici\n}',
    testsC: '#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char buf[50];\n    hello_world(buf);\n    assert(strcmp(buf, "Hello, World!") == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'import sys\n\nresult = hello_world()\nassert result == "Hello, World!", f"Expected \'Hello, World!\' but got \'{result}\'"\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { helloWorld } from "./solution";\n\nconst result = helloWorld();\nif (result !== "Hello, World!") throw new Error(`Expected "Hello, World!" but got "${result}"`);\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "add-two-numbers",
    title: "Additionner Deux Nombres",
    description: "Écrivez une fonction qui prend deux nombres et retourne leur somme.",
    difficulty: "easy",
    orderIndex: 2,
    tags: ["basics", "math"],
    templateC: '#include <stdio.h>\n\nint add(int a, int b) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def add(a: int, b: int) -> int:\n    """Retourne la somme de a et b"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function add(a: number, b: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(add(1, 2) == 3);\n    assert(add(-1, 1) == 0);\n    assert(add(0, 0) == 0);\n    assert(add(100, 200) == 300);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert add(1, 2) == 3\nassert add(-1, 1) == 0\nassert add(0, 0) == 0\nassert add(100, 200) == 300\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { add } from "./solution";\nif (add(1, 2) !== 3) throw new Error("Failed 1+2");\nif (add(-1, 1) !== 0) throw new Error("Failed -1+1");\nif (add(0, 0) !== 0) throw new Error("Failed 0+0");\nif (add(100, 200) !== 300) throw new Error("Failed 100+200");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "is-even",
    title: "Nombre Pair",
    description: "Écrivez une fonction qui retourne `true` si un nombre est pair, `false` sinon.",
    difficulty: "easy",
    orderIndex: 3,
    tags: ["basics", "math"],
    templateC: '#include <stdbool.h>\n\nbool is_even(int n) {\n    // Votre code ici\n    return false;\n}',
    templatePython: 'def is_even(n: int) -> bool:\n    """Retourne True si n est pair"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function isEven(n: number): boolean {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    assert(is_even(2) == true);\n    assert(is_even(3) == false);\n    assert(is_even(0) == true);\n    assert(is_even(-4) == true);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert is_even(2) == True\nassert is_even(3) == False\nassert is_even(0) == True\nassert is_even(-4) == True\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { isEven } from "./solution";\nif (isEven(2) !== true) throw new Error("2 should be even");\nif (isEven(3) !== false) throw new Error("3 should not be even");\nif (isEven(0) !== true) throw new Error("0 should be even");\nif (isEven(-4) !== true) throw new Error("-4 should be even");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "absolute-value",
    title: "Valeur Absolue",
    description: "Écrivez une fonction qui retourne la valeur absolue d'un nombre.\n\nNote: Implémentez-la sans utiliser les fonctions built-in abs().",
    difficulty: "easy",
    orderIndex: 4,
    tags: ["basics", "math"],
    templateC: 'int absolute(int n) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def absolute(n: int) -> int:\n    """Retourne la valeur absolue de n"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function absolute(n: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(absolute(5) == 5);\n    assert(absolute(-5) == 5);\n    assert(absolute(0) == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert absolute(5) == 5\nassert absolute(-5) == 5\nassert absolute(0) == 0\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { absolute } from "./solution";\nif (absolute(5) !== 5) throw new Error("Failed for 5");\nif (absolute(-5) !== 5) throw new Error("Failed for -5");\nif (absolute(0) !== 0) throw new Error("Failed for 0");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "max-of-two",
    title: "Maximum de Deux Nombres",
    description: "Écrivez une fonction qui retourne le plus grand de deux nombres.",
    difficulty: "easy",
    orderIndex: 5,
    tags: ["basics", "math"],
    templateC: 'int max_of_two(int a, int b) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def max_of_two(a: int, b: int) -> int:\n    """Retourne le plus grand entre a et b"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function maxOfTwo(a: number, b: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(max_of_two(3, 5) == 5);\n    assert(max_of_two(10, 2) == 10);\n    assert(max_of_two(7, 7) == 7);\n    assert(max_of_two(-1, -5) == -1);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert max_of_two(3, 5) == 5\nassert max_of_two(10, 2) == 10\nassert max_of_two(7, 7) == 7\nassert max_of_two(-1, -5) == -1\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { maxOfTwo } from "./solution";\nif (maxOfTwo(3, 5) !== 5) throw new Error("Failed");\nif (maxOfTwo(10, 2) !== 10) throw new Error("Failed");\nif (maxOfTwo(7, 7) !== 7) throw new Error("Failed");\nif (maxOfTwo(-1, -5) !== -1) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  // === CONTROL FLOW (6-15) ===
  {
    slug: "fizzbuzz",
    title: "FizzBuzz",
    description: "Écrivez une fonction FizzBuzz classique:\n- Retourne \"Fizz\" si le nombre est divisible par 3\n- Retourne \"Buzz\" si divisible par 5\n- Retourne \"FizzBuzz\" si divisible par 3 ET 5\n- Sinon, retourne le nombre en chaîne",
    difficulty: "easy",
    orderIndex: 6,
    tags: ["control-flow", "classic"],
    templateC: '#include <stdio.h>\n#include <string.h>\n\nvoid fizzbuzz(int n, char *result) {\n    // Votre code ici\n}',
    templatePython: 'def fizzbuzz(n: int) -> str:\n    """Retourne Fizz, Buzz, FizzBuzz ou le nombre en string"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function fizzbuzz(n: number): string {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char buf[20];\n    fizzbuzz(3, buf); assert(strcmp(buf, "Fizz") == 0);\n    fizzbuzz(5, buf); assert(strcmp(buf, "Buzz") == 0);\n    fizzbuzz(15, buf); assert(strcmp(buf, "FizzBuzz") == 0);\n    fizzbuzz(7, buf); assert(strcmp(buf, "7") == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert fizzbuzz(3) == "Fizz"\nassert fizzbuzz(5) == "Buzz"\nassert fizzbuzz(15) == "FizzBuzz"\nassert fizzbuzz(7) == "7"\nassert fizzbuzz(1) == "1"\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { fizzbuzz } from "./solution";\nif (fizzbuzz(3) !== "Fizz") throw new Error("Failed 3");\nif (fizzbuzz(5) !== "Buzz") throw new Error("Failed 5");\nif (fizzbuzz(15) !== "FizzBuzz") throw new Error("Failed 15");\nif (fizzbuzz(7) !== "7") throw new Error("Failed 7");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "factorial",
    title: "Factorielle",
    description: "Écrivez une fonction qui calcule la factorielle d'un nombre n.\n\nRappel: n! = n × (n-1) × ... × 1, et 0! = 1",
    difficulty: "easy",
    orderIndex: 7,
    tags: ["control-flow", "math", "recursion"],
    templateC: 'long factorial(int n) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def factorial(n: int) -> int:\n    """Calcule la factorielle de n"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function factorial(n: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(factorial(0) == 1);\n    assert(factorial(1) == 1);\n    assert(factorial(5) == 120);\n    assert(factorial(10) == 3628800);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert factorial(0) == 1\nassert factorial(1) == 1\nassert factorial(5) == 120\nassert factorial(10) == 3628800\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { factorial } from "./solution";\nif (factorial(0) !== 1) throw new Error("Failed 0!");\nif (factorial(1) !== 1) throw new Error("Failed 1!");\nif (factorial(5) !== 120) throw new Error("Failed 5!");\nif (factorial(10) !== 3628800) throw new Error("Failed 10!");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "fibonacci",
    title: "Fibonacci",
    description: "Écrivez une fonction qui retourne le n-ième nombre de Fibonacci.\n\nLa suite: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\nfib(0) = 0, fib(1) = 1, fib(n) = fib(n-1) + fib(n-2)",
    difficulty: "easy",
    orderIndex: 8,
    tags: ["control-flow", "math", "recursion"],
    templateC: 'int fibonacci(int n) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def fibonacci(n: int) -> int:\n    """Retourne le n-ième nombre de Fibonacci"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function fibonacci(n: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(fibonacci(0) == 0);\n    assert(fibonacci(1) == 1);\n    assert(fibonacci(6) == 8);\n    assert(fibonacci(10) == 55);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(6) == 8\nassert fibonacci(10) == 55\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { fibonacci } from "./solution";\nif (fibonacci(0) !== 0) throw new Error("Failed fib(0)");\nif (fibonacci(1) !== 1) throw new Error("Failed fib(1)");\nif (fibonacci(6) !== 8) throw new Error("Failed fib(6)");\nif (fibonacci(10) !== 55) throw new Error("Failed fib(10)");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "is-prime",
    title: "Nombre Premier",
    description: "Écrivez une fonction qui détermine si un nombre est premier.\n\nUn nombre premier est supérieur à 1 et n'est divisible que par 1 et lui-même.",
    difficulty: "easy",
    orderIndex: 9,
    tags: ["control-flow", "math"],
    templateC: '#include <stdbool.h>\n\nbool is_prime(int n) {\n    // Votre code ici\n    return false;\n}',
    templatePython: 'def is_prime(n: int) -> bool:\n    """Retourne True si n est premier"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function isPrime(n: number): boolean {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    assert(is_prime(2) == true);\n    assert(is_prime(7) == true);\n    assert(is_prime(1) == false);\n    assert(is_prime(4) == false);\n    assert(is_prime(13) == true);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert is_prime(2) == True\nassert is_prime(7) == True\nassert is_prime(1) == False\nassert is_prime(4) == False\nassert is_prime(13) == True\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { isPrime } from "./solution";\nif (isPrime(2) !== true) throw new Error("2 is prime");\nif (isPrime(7) !== true) throw new Error("7 is prime");\nif (isPrime(1) !== false) throw new Error("1 is not prime");\nif (isPrime(4) !== false) throw new Error("4 is not prime");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "sum-array",
    title: "Somme d'un Tableau",
    description: "Écrivez une fonction qui calcule la somme de tous les éléments d'un tableau.",
    difficulty: "easy",
    orderIndex: 10,
    tags: ["control-flow", "arrays"],
    templateC: 'int sum_array(int arr[], int size) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def sum_array(arr: list[int]) -> int:\n    """Retourne la somme des éléments"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function sumArray(arr: number[]): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a1[] = {1,2,3,4,5};\n    assert(sum_array(a1, 5) == 15);\n    int a2[] = {-1,1};\n    assert(sum_array(a2, 2) == 0);\n    assert(sum_array(NULL, 0) == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert sum_array([1,2,3,4,5]) == 15\nassert sum_array([-1,1]) == 0\nassert sum_array([]) == 0\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { sumArray } from "./solution";\nif (sumArray([1,2,3,4,5]) !== 15) throw new Error("Failed");\nif (sumArray([-1,1]) !== 0) throw new Error("Failed");\nif (sumArray([]) !== 0) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  // === FUNCTIONS (11-20) ===
  {
    slug: "power",
    title: "Puissance",
    description: "Écrivez une fonction qui calcule base^exponent (puissance).\n\nNote: L'exposant sera toujours >= 0.",
    difficulty: "easy",
    orderIndex: 11,
    tags: ["functions", "math"],
    templateC: 'long power(int base, int exp) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def power(base: int, exp: int) -> int:\n    """Calcule base^exp"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function power(base: number, exp: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(power(2, 3) == 8);\n    assert(power(5, 0) == 1);\n    assert(power(3, 4) == 81);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert power(2, 3) == 8\nassert power(5, 0) == 1\nassert power(3, 4) == 81\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { power } from "./solution";\nif (power(2, 3) !== 8) throw new Error("Failed");\nif (power(5, 0) !== 1) throw new Error("Failed");\nif (power(3, 4) !== 81) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "reverse-string",
    title: "Inverser une Chaîne",
    description: "Écrivez une fonction qui inverse une chaîne de caractères.\n\nExemple: \"hello\" → \"olleh\"",
    difficulty: "easy",
    orderIndex: 12,
    tags: ["functions", "strings"],
    templateC: '#include <string.h>\n\nvoid reverse_string(char *str) {\n    // Votre code ici - modifier str sur place\n}',
    templatePython: 'def reverse_string(s: str) -> str:\n    """Inverse la chaîne"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function reverseString(s: string): string {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s1[] = "hello";\n    reverse_string(s1);\n    assert(strcmp(s1, "olleh") == 0);\n    char s2[] = "";\n    reverse_string(s2);\n    assert(strcmp(s2, "") == 0);\n    char s3[] = "a";\n    reverse_string(s3);\n    assert(strcmp(s3, "a") == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert reverse_string("hello") == "olleh"\nassert reverse_string("") == ""\nassert reverse_string("a") == "a"\nassert reverse_string("abcd") == "dcba"\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { reverseString } from "./solution";\nif (reverseString("hello") !== "olleh") throw new Error("Failed");\nif (reverseString("") !== "") throw new Error("Failed");\nif (reverseString("a") !== "a") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "count-vowels",
    title: "Compter les Voyelles",
    description: "Écrivez une fonction qui compte le nombre de voyelles (a, e, i, o, u) dans une chaîne.\n\nLa fonction doit être insensible à la casse.",
    difficulty: "easy",
    orderIndex: 13,
    tags: ["functions", "strings"],
    templateC: 'int count_vowels(const char *str) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def count_vowels(s: str) -> int:\n    """Compte les voyelles dans la chaîne"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function countVowels(s: string): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(count_vowels("hello") == 2);\n    assert(count_vowels("AEIOU") == 5);\n    assert(count_vowels("xyz") == 0);\n    assert(count_vowels("") == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert count_vowels("hello") == 2\nassert count_vowels("AEIOU") == 5\nassert count_vowels("xyz") == 0\nassert count_vowels("") == 0\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { countVowels } from "./solution";\nif (countVowels("hello") !== 2) throw new Error("Failed");\nif (countVowels("AEIOU") !== 5) throw new Error("Failed");\nif (countVowels("xyz") !== 0) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "palindrome",
    title: "Palindrome",
    description: "Écrivez une fonction qui vérifie si une chaîne est un palindrome.\n\nUn palindrome se lit de la même façon dans les deux sens.\nIgnorez la casse. Exemples: \"racecar\" → true, \"hello\" → false",
    difficulty: "easy",
    orderIndex: 14,
    tags: ["functions", "strings"],
    templateC: '#include <stdbool.h>\n\nbool is_palindrome(const char *str) {\n    // Votre code ici\n    return false;\n}',
    templatePython: 'def is_palindrome(s: str) -> bool:\n    """Vérifie si la chaîne est un palindrome"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function isPalindrome(s: string): boolean {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    assert(is_palindrome("racecar") == true);\n    assert(is_palindrome("hello") == false);\n    assert(is_palindrome("") == true);\n    assert(is_palindrome("A") == true);\n    assert(is_palindrome("Aba") == true);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert is_palindrome("racecar") == True\nassert is_palindrome("hello") == False\nassert is_palindrome("") == True\nassert is_palindrome("Aba") == True\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { isPalindrome } from "./solution";\nif (isPalindrome("racecar") !== true) throw new Error("Failed");\nif (isPalindrome("hello") !== false) throw new Error("Failed");\nif (isPalindrome("Aba") !== true) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "gcd",
    title: "PGCD (Plus Grand Commun Diviseur)",
    description: "Écrivez une fonction qui calcule le PGCD de deux nombres positifs.\n\nUtilisez l'algorithme d'Euclide.",
    difficulty: "medium",
    orderIndex: 15,
    tags: ["functions", "math"],
    templateC: 'int gcd(int a, int b) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def gcd(a: int, b: int) -> int:\n    """Calcule le PGCD de a et b"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function gcd(a: number, b: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(gcd(12, 8) == 4);\n    assert(gcd(7, 13) == 1);\n    assert(gcd(100, 25) == 25);\n    assert(gcd(0, 5) == 5);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert gcd(12, 8) == 4\nassert gcd(7, 13) == 1\nassert gcd(100, 25) == 25\nassert gcd(0, 5) == 5\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { gcd } from "./solution";\nif (gcd(12, 8) !== 4) throw new Error("Failed");\nif (gcd(7, 13) !== 1) throw new Error("Failed");\nif (gcd(100, 25) !== 25) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  // === DATA STRUCTURES (16-25) ===
  {
    slug: "find-max",
    title: "Trouver le Maximum",
    description: "Écrivez une fonction qui trouve la valeur maximale dans un tableau de nombres.",
    difficulty: "easy",
    orderIndex: 16,
    tags: ["data-structures", "arrays"],
    templateC: '#include <limits.h>\n\nint find_max(int arr[], int size) {\n    // Votre code ici\n    return INT_MIN;\n}',
    templatePython: 'def find_max(arr: list[int]) -> int:\n    """Trouve le maximum dans le tableau"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function findMax(arr: number[]): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a1[] = {3,1,4,1,5,9};\n    assert(find_max(a1, 6) == 9);\n    int a2[] = {-5,-1,-3};\n    assert(find_max(a2, 3) == -1);\n    int a3[] = {42};\n    assert(find_max(a3, 1) == 42);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert find_max([3,1,4,1,5,9]) == 9\nassert find_max([-5,-1,-3]) == -1\nassert find_max([42]) == 42\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { findMax } from "./solution";\nif (findMax([3,1,4,1,5,9]) !== 9) throw new Error("Failed");\nif (findMax([-5,-1,-3]) !== -1) throw new Error("Failed");\nif (findMax([42]) !== 42) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "remove-duplicates",
    title: "Supprimer les Doublons",
    description: "Écrivez une fonction qui supprime les doublons d'un tableau tout en préservant l'ordre.",
    difficulty: "medium",
    orderIndex: 17,
    tags: ["data-structures", "arrays"],
    templateC: '#include <stdlib.h>\n\n// Retourne la nouvelle taille du tableau (modifié sur place)\nint remove_duplicates(int arr[], int size) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def remove_duplicates(arr: list[int]) -> list[int]:\n    """Supprime les doublons en préservant l\'ordre"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function removeDuplicates(arr: number[]): number[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a1[] = {1,2,2,3,3,3};\n    int n1 = remove_duplicates(a1, 6);\n    assert(n1 == 3);\n    assert(a1[0]==1 && a1[1]==2 && a1[2]==3);\n    int a2[] = {1,1,1};\n    int n2 = remove_duplicates(a2, 3);\n    assert(n2 == 1);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert remove_duplicates([1,2,2,3,3,3]) == [1,2,3]\nassert remove_duplicates([1,1,1]) == [1]\nassert remove_duplicates([]) == []\nassert remove_duplicates([5,3,5,3,1]) == [5,3,1]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { removeDuplicates } from "./solution";\nconst r1 = removeDuplicates([1,2,2,3,3,3]);\nif (JSON.stringify(r1) !== "[1,2,3]") throw new Error("Failed");\nconst r2 = removeDuplicates([5,3,5,3,1]);\nif (JSON.stringify(r2) !== "[5,3,1]") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "two-sum",
    title: "Two Sum",
    description: "Étant donné un tableau de nombres et une cible, retournez les indices des deux nombres dont la somme est égale à la cible.\n\nVous pouvez supposer qu'il y a exactement une solution.",
    difficulty: "medium",
    orderIndex: 18,
    tags: ["data-structures", "arrays", "classic"],
    templateC: '#include <stdlib.h>\n\n// Retourne un tableau de 2 indices (à libérer par l\'appelant)\nint* two_sum(int nums[], int size, int target) {\n    // Votre code ici\n    return NULL;\n}',
    templatePython: 'def two_sum(nums: list[int], target: int) -> list[int]:\n    """Retourne les indices des deux nombres qui font la somme target"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function twoSum(nums: number[], target: number): [number, number] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int a1[] = {2,7,11,15};\n    int *r1 = two_sum(a1, 4, 9);\n    assert(r1[0]==0 && r1[1]==1);\n    free(r1);\n    int a2[] = {3,2,4};\n    int *r2 = two_sum(a2, 3, 6);\n    assert(r2[0]==1 && r2[1]==2);\n    free(r2);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert two_sum([2,7,11,15], 9) == [0,1]\nassert two_sum([3,2,4], 6) == [1,2]\nassert two_sum([3,3], 6) == [0,1]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { twoSum } from "./solution";\nconst r1 = twoSum([2,7,11,15], 9);\nif (r1[0] !== 0 || r1[1] !== 1) throw new Error("Failed");\nconst r2 = twoSum([3,2,4], 6);\nif (r2[0] !== 1 || r2[1] !== 2) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "rotate-array",
    title: "Rotation de Tableau",
    description: "Écrivez une fonction qui effectue une rotation à droite d'un tableau de k positions.\n\nExemple: [1,2,3,4,5] avec k=2 → [4,5,1,2,3]",
    difficulty: "medium",
    orderIndex: 19,
    tags: ["data-structures", "arrays"],
    templateC: 'void rotate_array(int arr[], int size, int k) {\n    // Votre code ici - modifier le tableau sur place\n}',
    templatePython: 'def rotate_array(arr: list[int], k: int) -> list[int]:\n    """Rotation à droite de k positions"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function rotateArray(arr: number[], k: number): number[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a1[] = {1,2,3,4,5};\n    rotate_array(a1, 5, 2);\n    assert(a1[0]==4 && a1[1]==5 && a1[2]==1 && a1[3]==2 && a1[4]==3);\n    int a2[] = {1,2,3};\n    rotate_array(a2, 3, 3);\n    assert(a2[0]==1 && a2[1]==2 && a2[2]==3);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert rotate_array([1,2,3,4,5], 2) == [4,5,1,2,3]\nassert rotate_array([1,2,3], 3) == [1,2,3]\nassert rotate_array([1,2,3], 1) == [3,1,2]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { rotateArray } from "./solution";\nif (JSON.stringify(rotateArray([1,2,3,4,5], 2)) !== "[4,5,1,2,3]") throw new Error("Failed");\nif (JSON.stringify(rotateArray([1,2,3], 3)) !== "[1,2,3]") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "flatten-array",
    title: "Aplatir un Tableau",
    description: "Écrivez une fonction qui aplatit un tableau imbriqué en un seul niveau.\n\nExemple: [1, [2, [3, 4]], 5] → [1, 2, 3, 4, 5]",
    difficulty: "medium",
    orderIndex: 20,
    tags: ["data-structures", "arrays", "recursion"],
    templateC: '// En C: aplatir un tableau 2D\nint flatten(int matrix[][10], int rows, int cols, int *result) {\n    // Copie les éléments dans result, retourne la taille\n    return 0;\n}',
    templatePython: 'def flatten(arr: list) -> list:\n    """Aplatit un tableau imbriqué"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function flatten(arr: any[]): any[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int matrix[2][10] = {{1,2,3},{4,5,6}};\n    int result[20];\n    int n = flatten(matrix, 2, 3, result);\n    assert(n == 6);\n    assert(result[0]==1 && result[3]==4 && result[5]==6);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert flatten([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5]\nassert flatten([]) == []\nassert flatten([1, 2, 3]) == [1, 2, 3]\nassert flatten([[1], [2], [3]]) == [1, 2, 3]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { flatten } from "./solution";\nif (JSON.stringify(flatten([1, [2, [3, 4]], 5])) !== "[1,2,3,4,5]") throw new Error("Failed");\nif (JSON.stringify(flatten([])) !== "[]") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  // === STRINGS (21-30) ===
  {
    slug: "capitalize-words",
    title: "Majuscule Initiale",
    description: "Écrivez une fonction qui met en majuscule la première lettre de chaque mot.\n\nExemple: \"hello world\" → \"Hello World\"",
    difficulty: "easy",
    orderIndex: 21,
    tags: ["strings"],
    templateC: '#include <ctype.h>\n\nvoid capitalize_words(char *str) {\n    // Modifier str sur place\n}',
    templatePython: 'def capitalize_words(s: str) -> str:\n    """Met en majuscule la première lettre de chaque mot"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function capitalizeWords(s: string): string {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s1[] = "hello world";\n    capitalize_words(s1);\n    assert(strcmp(s1, "Hello World") == 0);\n    char s2[] = "";\n    capitalize_words(s2);\n    assert(strcmp(s2, "") == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert capitalize_words("hello world") == "Hello World"\nassert capitalize_words("") == ""\nassert capitalize_words("a") == "A"\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { capitalizeWords } from "./solution";\nif (capitalizeWords("hello world") !== "Hello World") throw new Error("Failed");\nif (capitalizeWords("") !== "") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "count-words",
    title: "Compter les Mots",
    description: "Écrivez une fonction qui compte le nombre de mots dans une chaîne.\n\nLes mots sont séparés par des espaces. Ignorez les espaces multiples.",
    difficulty: "easy",
    orderIndex: 22,
    tags: ["strings"],
    templateC: 'int count_words(const char *str) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def count_words(s: str) -> int:\n    """Compte les mots dans la chaîne"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function countWords(s: string): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(count_words("hello world") == 2);\n    assert(count_words("  hello  world  ") == 2);\n    assert(count_words("") == 0);\n    assert(count_words("one") == 1);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert count_words("hello world") == 2\nassert count_words("  hello  world  ") == 2\nassert count_words("") == 0\nassert count_words("one") == 1\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { countWords } from "./solution";\nif (countWords("hello world") !== 2) throw new Error("Failed");\nif (countWords("  hello  world  ") !== 2) throw new Error("Failed");\nif (countWords("") !== 0) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "caesar-cipher",
    title: "Chiffre de César",
    description: "Implémentez le chiffre de César: décalez chaque lettre de `shift` positions dans l'alphabet.\n\nNe modifiez que les lettres (a-z, A-Z). Préservez la casse.",
    difficulty: "medium",
    orderIndex: 23,
    tags: ["strings", "classic"],
    templateC: 'void caesar_cipher(char *str, int shift) {\n    // Modifier str sur place\n}',
    templatePython: 'def caesar_cipher(s: str, shift: int) -> str:\n    """Applique le chiffre de César"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function caesarCipher(s: string, shift: number): string {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s1[] = "abc";\n    caesar_cipher(s1, 1);\n    assert(strcmp(s1, "bcd") == 0);\n    char s2[] = "xyz";\n    caesar_cipher(s2, 3);\n    assert(strcmp(s2, "abc") == 0);\n    char s3[] = "Hello!";\n    caesar_cipher(s3, 13);\n    assert(strcmp(s3, "Uryyb!") == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert caesar_cipher("abc", 1) == "bcd"\nassert caesar_cipher("xyz", 3) == "abc"\nassert caesar_cipher("Hello!", 13) == "Uryyb!"\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { caesarCipher } from "./solution";\nif (caesarCipher("abc", 1) !== "bcd") throw new Error("Failed");\nif (caesarCipher("xyz", 3) !== "abc") throw new Error("Failed");\nif (caesarCipher("Hello!", 13) !== "Uryyb!") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "anagram-check",
    title: "Vérifier un Anagramme",
    description: "Écrivez une fonction qui vérifie si deux chaînes sont des anagrammes l'une de l'autre.\n\nIgnorez la casse et les espaces.",
    difficulty: "medium",
    orderIndex: 24,
    tags: ["strings"],
    templateC: '#include <stdbool.h>\n\nbool is_anagram(const char *a, const char *b) {\n    // Votre code ici\n    return false;\n}',
    templatePython: 'def is_anagram(a: str, b: str) -> bool:\n    """Vérifie si a et b sont des anagrammes"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function isAnagram(a: string, b: string): boolean {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    assert(is_anagram("listen", "silent") == true);\n    assert(is_anagram("hello", "world") == false);\n    assert(is_anagram("Astronomer", "Moon starer") == true);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert is_anagram("listen", "silent") == True\nassert is_anagram("hello", "world") == False\nassert is_anagram("Astronomer", "Moon starer") == True\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { isAnagram } from "./solution";\nif (isAnagram("listen", "silent") !== true) throw new Error("Failed");\nif (isAnagram("hello", "world") !== false) throw new Error("Failed");\nif (isAnagram("Astronomer", "Moon starer") !== true) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "longest-common-prefix",
    title: "Plus Long Préfixe Commun",
    description: "Trouvez le plus long préfixe commun parmi un tableau de chaînes.\n\nSi aucun préfixe commun, retournez une chaîne vide.",
    difficulty: "medium",
    orderIndex: 25,
    tags: ["strings"],
    templateC: '#include <string.h>\n\nvoid longest_common_prefix(char *strs[], int count, char *result) {\n    // Écrit le résultat dans result\n}',
    templatePython: 'def longest_common_prefix(strs: list[str]) -> str:\n    """Trouve le plus long préfixe commun"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function longestCommonPrefix(strs: string[]): string {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char *s1[] = {"flower","flow","flight"};\n    char r1[50];\n    longest_common_prefix(s1, 3, r1);\n    assert(strcmp(r1, "fl") == 0);\n    char *s2[] = {"dog","racecar","car"};\n    char r2[50];\n    longest_common_prefix(s2, 3, r2);\n    assert(strcmp(r2, "") == 0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert longest_common_prefix(["flower","flow","flight"]) == "fl"\nassert longest_common_prefix(["dog","racecar","car"]) == ""\nassert longest_common_prefix(["a"]) == "a"\nassert longest_common_prefix([]) == ""\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { longestCommonPrefix } from "./solution";\nif (longestCommonPrefix(["flower","flow","flight"]) !== "fl") throw new Error("Failed");\nif (longestCommonPrefix(["dog","racecar","car"]) !== "") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  // === MORE ALGORITHMS (26-35) ===
  {
    slug: "binary-search",
    title: "Recherche Binaire",
    description: "Implémentez la recherche binaire dans un tableau trié.\n\nRetournez l'index de la cible, ou -1 si non trouvée.",
    difficulty: "medium",
    orderIndex: 26,
    tags: ["algorithms", "search"],
    templateC: 'int binary_search(int arr[], int size, int target) {\n    // Votre code ici\n    return -1;\n}',
    templatePython: 'def binary_search(arr: list[int], target: int) -> int:\n    """Recherche binaire, retourne l\'index ou -1"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function binarySearch(arr: number[], target: number): number {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a[] = {1,3,5,7,9,11};\n    assert(binary_search(a, 6, 7) == 3);\n    assert(binary_search(a, 6, 4) == -1);\n    assert(binary_search(a, 6, 1) == 0);\n    assert(binary_search(a, 6, 11) == 5);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert binary_search([1,3,5,7,9,11], 7) == 3\nassert binary_search([1,3,5,7,9,11], 4) == -1\nassert binary_search([1,3,5,7,9,11], 1) == 0\nassert binary_search([], 5) == -1\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { binarySearch } from "./solution";\nif (binarySearch([1,3,5,7,9,11], 7) !== 3) throw new Error("Failed");\nif (binarySearch([1,3,5,7,9,11], 4) !== -1) throw new Error("Failed");\nif (binarySearch([], 5) !== -1) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "bubble-sort",
    title: "Tri à Bulles",
    description: "Implémentez l'algorithme de tri à bulles.\n\nTriez le tableau en ordre croissant.",
    difficulty: "medium",
    orderIndex: 27,
    tags: ["algorithms", "sorting"],
    templateC: 'void bubble_sort(int arr[], int size) {\n    // Votre code ici - trier sur place\n}',
    templatePython: 'def bubble_sort(arr: list[int]) -> list[int]:\n    """Tri à bulles"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function bubbleSort(arr: number[]): number[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a[] = {5,3,8,1,2};\n    bubble_sort(a, 5);\n    assert(a[0]==1 && a[1]==2 && a[2]==3 && a[3]==5 && a[4]==8);\n    int b[] = {1};\n    bubble_sort(b, 1);\n    assert(b[0] == 1);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert bubble_sort([5,3,8,1,2]) == [1,2,3,5,8]\nassert bubble_sort([1]) == [1]\nassert bubble_sort([]) == []\nassert bubble_sort([3,1]) == [1,3]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { bubbleSort } from "./solution";\nif (JSON.stringify(bubbleSort([5,3,8,1,2])) !== "[1,2,3,5,8]") throw new Error("Failed");\nif (JSON.stringify(bubbleSort([])) !== "[]") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "merge-sorted-arrays",
    title: "Fusionner Deux Tableaux Triés",
    description: "Fusionnez deux tableaux triés en un seul tableau trié.",
    difficulty: "medium",
    orderIndex: 28,
    tags: ["algorithms", "arrays"],
    templateC: '#include <stdlib.h>\n\nint* merge_sorted(int a[], int sizeA, int b[], int sizeB, int *resultSize) {\n    // Votre code ici\n    return NULL;\n}',
    templatePython: 'def merge_sorted(a: list[int], b: list[int]) -> list[int]:\n    """Fusionne deux tableaux triés"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function mergeSorted(a: number[], b: number[]): number[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int a[] = {1,3,5};\n    int b[] = {2,4,6};\n    int size;\n    int *r = merge_sorted(a, 3, b, 3, &size);\n    assert(size == 6);\n    assert(r[0]==1 && r[1]==2 && r[2]==3 && r[3]==4 && r[4]==5 && r[5]==6);\n    free(r);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert merge_sorted([1,3,5], [2,4,6]) == [1,2,3,4,5,6]\nassert merge_sorted([], [1,2]) == [1,2]\nassert merge_sorted([1], []) == [1]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { mergeSorted } from "./solution";\nif (JSON.stringify(mergeSorted([1,3,5], [2,4,6])) !== "[1,2,3,4,5,6]") throw new Error("Failed");\nif (JSON.stringify(mergeSorted([], [1,2])) !== "[1,2]") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "matrix-transpose",
    title: "Transposée de Matrice",
    description: "Écrivez une fonction qui retourne la transposée d'une matrice (lignes ↔ colonnes).\n\nExemple: [[1,2,3],[4,5,6]] → [[1,4],[2,5],[3,6]]",
    difficulty: "medium",
    orderIndex: 29,
    tags: ["algorithms", "arrays"],
    templateC: 'void transpose(int matrix[][3], int rows, int cols, int result[][2]) {\n    // Votre code ici\n}',
    templatePython: 'def transpose(matrix: list[list[int]]) -> list[list[int]]:\n    """Retourne la transposée de la matrice"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function transpose(matrix: number[][]): number[][] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int m[2][3] = {{1,2,3},{4,5,6}};\n    int r[3][2];\n    transpose(m, 2, 3, r);\n    assert(r[0][0]==1 && r[0][1]==4);\n    assert(r[1][0]==2 && r[1][1]==5);\n    assert(r[2][0]==3 && r[2][1]==6);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert transpose([[1,2,3],[4,5,6]]) == [[1,4],[2,5],[3,6]]\nassert transpose([[1]]) == [[1]]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { transpose } from "./solution";\nif (JSON.stringify(transpose([[1,2,3],[4,5,6]])) !== "[[1,4],[2,5],[3,6]]") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "valid-parentheses",
    title: "Parenthèses Valides",
    description: "Déterminez si une chaîne contenant uniquement '(', ')', '{', '}', '[', ']' est valide.\n\nUne chaîne est valide si chaque parenthèse ouvrante est fermée par le même type dans le bon ordre.",
    difficulty: "medium",
    orderIndex: 30,
    tags: ["algorithms", "stack", "classic"],
    templateC: '#include <stdbool.h>\n\nbool valid_parentheses(const char *s) {\n    // Votre code ici\n    return false;\n}',
    templatePython: 'def valid_parentheses(s: str) -> bool:\n    """Vérifie si les parenthèses sont valides"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function validParentheses(s: string): boolean {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    assert(valid_parentheses("()") == true);\n    assert(valid_parentheses("()[]{}") == true);\n    assert(valid_parentheses("(]") == false);\n    assert(valid_parentheses("([)]") == false);\n    assert(valid_parentheses("{[]}") == true);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert valid_parentheses("()") == True\nassert valid_parentheses("()[]{}") == True\nassert valid_parentheses("(]") == False\nassert valid_parentheses("([)]") == False\nassert valid_parentheses("{[]}") == True\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { validParentheses } from "./solution";\nif (validParentheses("()") !== true) throw new Error("Failed");\nif (validParentheses("(]") !== false) throw new Error("Failed");\nif (validParentheses("{[]}") !== true) throw new Error("Failed");\nif (validParentheses("([)]") !== false) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  // === HARDER (31-40) ===
  {
    slug: "linked-list-reverse",
    title: "Inverser une Liste Chaînée",
    description: "Implémentez une fonction pour inverser une liste chaînée (singly linked list).",
    difficulty: "medium",
    orderIndex: 31,
    tags: ["data-structures", "linked-list"],
    templateC: 'typedef struct Node {\n    int val;\n    struct Node *next;\n} Node;\n\nNode* reverse_list(Node *head) {\n    // Votre code ici\n    return NULL;\n}',
    templatePython: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head: ListNode) -> ListNode:\n    """Inverse la liste chaînée"""\n    # Votre code ici\n    pass',
    templateTypescript: 'class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val = 0, next: ListNode | null = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nexport function reverseList(head: ListNode | null): ListNode | null {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nNode* create(int vals[], int n) {\n    Node *head = NULL, *tail = NULL;\n    for(int i=0;i<n;i++) {\n        Node *node = malloc(sizeof(Node));\n        node->val = vals[i]; node->next = NULL;\n        if(!head) head = node; else tail->next = node;\n        tail = node;\n    }\n    return head;\n}\n\nint main() {\n    int v[] = {1,2,3,4,5};\n    Node *h = reverse_list(create(v, 5));\n    assert(h->val==5 && h->next->val==4);\n    assert(reverse_list(NULL) == NULL);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'def to_list(head):\n    r = []\n    while head:\n        r.append(head.val)\n        head = head.next\n    return r\n\ndef from_list(arr):\n    head = None\n    for v in reversed(arr):\n        head = ListNode(v, head)\n    return head\n\nassert to_list(reverse_list(from_list([1,2,3,4,5]))) == [5,4,3,2,1]\nassert reverse_list(None) is None\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { reverseList } from "./solution";\n\nfunction fromArr(arr: number[]): ListNode | null {\n  let head: ListNode | null = null;\n  for (let i = arr.length - 1; i >= 0; i--) head = new ListNode(arr[i], head);\n  return head;\n}\nfunction toArr(head: ListNode | null): number[] {\n  const r: number[] = [];\n  while (head) { r.push(head.val); head = head.next; }\n  return r;\n}\nif (JSON.stringify(toArr(reverseList(fromArr([1,2,3])))) !== "[3,2,1]") throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "stack-implementation",
    title: "Implémenter une Pile (Stack)",
    description: "Implémentez une structure de pile avec les opérations push, pop, peek et isEmpty.",
    difficulty: "medium",
    orderIndex: 32,
    tags: ["data-structures", "stack"],
    templateC: '#include <stdbool.h>\n#define MAX_SIZE 100\n\ntypedef struct {\n    int data[MAX_SIZE];\n    int top;\n} Stack;\n\nvoid stack_init(Stack *s) { s->top = -1; }\nvoid stack_push(Stack *s, int val) { /* Votre code */ }\nint stack_pop(Stack *s) { /* Votre code */ return -1; }\nint stack_peek(Stack *s) { /* Votre code */ return -1; }\nbool stack_empty(Stack *s) { /* Votre code */ return true; }',
    templatePython: 'class Stack:\n    def __init__(self):\n        # Votre code ici\n        pass\n\n    def push(self, val: int) -> None:\n        pass\n\n    def pop(self) -> int:\n        pass\n\n    def peek(self) -> int:\n        pass\n\n    def is_empty(self) -> bool:\n        pass',
    templateTypescript: 'export class Stack {\n  // Votre code ici\n\n  push(val: number): void {}\n  pop(): number | undefined { return undefined; }\n  peek(): number | undefined { return undefined; }\n  isEmpty(): boolean { return true; }\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    Stack s;\n    stack_init(&s);\n    assert(stack_empty(&s) == true);\n    stack_push(&s, 10);\n    stack_push(&s, 20);\n    assert(stack_peek(&s) == 20);\n    assert(stack_pop(&s) == 20);\n    assert(stack_pop(&s) == 10);\n    assert(stack_empty(&s) == true);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 's = Stack()\nassert s.is_empty() == True\ns.push(10)\ns.push(20)\nassert s.peek() == 20\nassert s.pop() == 20\nassert s.pop() == 10\nassert s.is_empty() == True\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { Stack } from "./solution";\nconst s = new Stack();\nif (!s.isEmpty()) throw new Error("Should be empty");\ns.push(10); s.push(20);\nif (s.peek() !== 20) throw new Error("Peek failed");\nif (s.pop() !== 20) throw new Error("Pop failed");\nif (s.pop() !== 10) throw new Error("Pop failed");\nif (!s.isEmpty()) throw new Error("Should be empty");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "queue-implementation",
    title: "Implémenter une File (Queue)",
    description: "Implémentez une file (FIFO) avec les opérations enqueue, dequeue, front et isEmpty.",
    difficulty: "medium",
    orderIndex: 33,
    tags: ["data-structures", "queue"],
    templateC: '#include <stdbool.h>\n#define MAX_SIZE 100\n\ntypedef struct {\n    int data[MAX_SIZE];\n    int front, rear, size;\n} Queue;\n\nvoid queue_init(Queue *q) { q->front=0; q->rear=-1; q->size=0; }\nvoid enqueue(Queue *q, int val) { /* Votre code */ }\nint dequeue(Queue *q) { /* Votre code */ return -1; }\nint queue_front(Queue *q) { /* Votre code */ return -1; }\nbool queue_empty(Queue *q) { /* Votre code */ return true; }',
    templatePython: 'class Queue:\n    def __init__(self):\n        pass\n\n    def enqueue(self, val: int) -> None:\n        pass\n\n    def dequeue(self) -> int:\n        pass\n\n    def front(self) -> int:\n        pass\n\n    def is_empty(self) -> bool:\n        pass',
    templateTypescript: 'export class Queue {\n  enqueue(val: number): void {}\n  dequeue(): number | undefined { return undefined; }\n  front(): number | undefined { return undefined; }\n  isEmpty(): boolean { return true; }\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    Queue q;\n    queue_init(&q);\n    assert(queue_empty(&q) == true);\n    enqueue(&q, 10);\n    enqueue(&q, 20);\n    assert(queue_front(&q) == 10);\n    assert(dequeue(&q) == 10);\n    assert(dequeue(&q) == 20);\n    assert(queue_empty(&q) == true);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'q = Queue()\nassert q.is_empty() == True\nq.enqueue(10)\nq.enqueue(20)\nassert q.front() == 10\nassert q.dequeue() == 10\nassert q.dequeue() == 20\nassert q.is_empty() == True\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { Queue } from "./solution";\nconst q = new Queue();\nif (!q.isEmpty()) throw new Error("Should be empty");\nq.enqueue(10); q.enqueue(20);\nif (q.front() !== 10) throw new Error("Front failed");\nif (q.dequeue() !== 10) throw new Error("Dequeue failed");\nif (q.dequeue() !== 20) throw new Error("Dequeue failed");\nif (!q.isEmpty()) throw new Error("Should be empty");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "word-frequency",
    title: "Fréquence des Mots",
    description: "Écrivez une fonction qui compte la fréquence de chaque mot dans une chaîne.\n\nRetournez un dictionnaire/map mot → nombre. Insensible à la casse.",
    difficulty: "medium",
    orderIndex: 34,
    tags: ["strings", "data-structures"],
    templateC: '// En C: compter la fréquence du mot le plus fréquent\nint most_frequent_count(const char *text) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'def word_frequency(text: str) -> dict[str, int]:\n    """Retourne la fréquence de chaque mot"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function wordFrequency(text: string): Record<string, number> {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(most_frequent_count("the cat and the dog") == 2);\n    assert(most_frequent_count("a a a b b") == 3);\n    assert(most_frequent_count("hello") == 1);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'r = word_frequency("the cat and the dog")\nassert r["the"] == 2\nassert r["cat"] == 1\nr2 = word_frequency("Hello hello")\nassert r2["hello"] == 2\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { wordFrequency } from "./solution";\nconst r = wordFrequency("the cat and the dog");\nif (r["the"] !== 2) throw new Error("Failed");\nif (r["cat"] !== 1) throw new Error("Failed");\nconst r2 = wordFrequency("Hello hello");\nif (r2["hello"] !== 2) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "deep-clone",
    title: "Clone Profond",
    description: "Implémentez une fonction de clonage profond (deep clone) qui copie un objet et tous ses sous-objets.\n\nNote: Gérez les objets, tableaux et valeurs primitives.",
    difficulty: "hard",
    orderIndex: 35,
    tags: ["data-structures", "recursion"],
    templateC: '// En C: deep clone d\'un tableau\nvoid deep_clone_array(int src[], int dest[], int size) {\n    // Votre code ici\n}',
    templatePython: 'def deep_clone(obj):\n    """Clone profond d\'un objet"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function deepClone<T>(obj: T): T {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int src[] = {1,2,3,4,5};\n    int dest[5];\n    deep_clone_array(src, dest, 5);\n    assert(dest[0]==1 && dest[4]==5);\n    dest[0] = 99;\n    assert(src[0] == 1);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'original = {"a": [1, 2, {"b": 3}]}\ncloned = deep_clone(original)\nassert cloned == original\ncloned["a"][2]["b"] = 99\nassert original["a"][2]["b"] == 3\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { deepClone } from "./solution";\nconst orig = { a: [1, 2, { b: 3 }] };\nconst cloned = deepClone(orig);\nif (cloned.a[2].b !== 3) throw new Error("Failed clone");\n(cloned.a[2] as any).b = 99;\nif ((orig.a[2] as any).b !== 3) throw new Error("Not deep");\nconsole.log("ALL TESTS PASSED");',
  },
  // === HARDER (36-40) ===
  {
    slug: "debounce",
    title: "Debounce",
    description: "Implémentez une fonction debounce qui retarde l'exécution d'une fonction.\n\nLa fonction ne s'exécute qu'après que `delay` ms se soient écoulées depuis le dernier appel.",
    difficulty: "hard",
    orderIndex: 36,
    tags: ["functions", "async"],
    templateC: '// N/A en C - Exercice Python/TypeScript uniquement\n// En C: implémenter un compteur avec cooldown\nint counter = 0;\nvoid increment() { counter++; }\nint get_counter() { return counter; }',
    templatePython: 'import time\nfrom typing import Callable\n\ndef debounce(func: Callable, delay_ms: int) -> Callable:\n    """Retourne une version debounced de func"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  delayMs: number\n): T {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    counter = 0;\n    increment();\n    increment();\n    assert(get_counter() == 2);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'import time\ncall_count = 0\ndef my_func():\n    global call_count\n    call_count += 1\n\ndebounced = debounce(my_func, 100)\ndebounced()\ndebounced()\ndebounced()\ntime.sleep(0.15)\nassert call_count == 1, f"Expected 1 call but got {call_count}"\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { debounce } from "./solution";\nlet count = 0;\nconst fn = debounce(() => { count++; }, 100);\nfn(); fn(); fn();\nawait new Promise(r => setTimeout(r, 150));\nif (count !== 1) throw new Error(`Expected 1 call but got ${count}`);\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "memoize",
    title: "Mémoïsation",
    description: "Implémentez une fonction de mémoïsation qui cache les résultats des appels précédents.\n\nSi la fonction est appelée avec les mêmes arguments, retournez le résultat du cache.",
    difficulty: "hard",
    orderIndex: 37,
    tags: ["functions", "optimization"],
    templateC: '// En C: cache simple pour fibonacci\nlong fib_memo(int n) {\n    // Implémentez fibonacci avec mémoïsation\n    return 0;\n}',
    templatePython: 'from typing import Callable\n\ndef memoize(func: Callable) -> Callable:\n    """Retourne une version mémoïsée de func"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function memoize<T extends (...args: any[]) => any>(func: T): T {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(fib_memo(0) == 0);\n    assert(fib_memo(10) == 55);\n    assert(fib_memo(30) == 832040);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'call_count = 0\ndef expensive(x):\n    global call_count\n    call_count += 1\n    return x * 2\n\nmemo = memoize(expensive)\nassert memo(5) == 10\nassert memo(5) == 10\nassert call_count == 1\nassert memo(3) == 6\nassert call_count == 2\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { memoize } from "./solution";\nlet calls = 0;\nconst fn = memoize((x: number) => { calls++; return x * 2; });\nif (fn(5) !== 10) throw new Error("Wrong result");\nif (fn(5) !== 10) throw new Error("Wrong cached result");\nif (calls !== 1) throw new Error("Should have cached");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "promise-all",
    title: "Promise.all",
    description: "Implémentez votre propre version de Promise.all.\n\nElle doit résoudre quand toutes les promesses sont résolues, ou rejeter dès qu'une échoue.",
    difficulty: "hard",
    orderIndex: 38,
    tags: ["async", "functions"],
    templateC: '// N/A en C\n#include <stdio.h>\nint main() { printf("ALL TESTS PASSED\\n"); return 0; }',
    templatePython: 'import asyncio\n\nasync def promise_all(tasks: list) -> list:\n    """Attend que toutes les coroutines soient terminées"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function promiseAll<T>(promises: Promise<T>[]): Promise<T[]> {\n  // Votre code ici\n}',
    testsC: '',
    testsPython: 'import asyncio\n\nasync def test():\n    async def ok(v, d=0):\n        await asyncio.sleep(d)\n        return v\n\n    r = await promise_all([ok(1, 0.01), ok(2, 0.02), ok(3, 0.01)])\n    assert r == [1, 2, 3]\n\n    try:\n        async def fail():\n            raise ValueError("oops")\n        await promise_all([ok(1), fail()])\n        assert False, "Should have raised"\n    except ValueError:\n        pass\n\nasyncio.run(test())\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { promiseAll } from "./solution";\nconst r = await promiseAll([Promise.resolve(1), Promise.resolve(2)]);\nif (JSON.stringify(r) !== "[1,2]") throw new Error("Failed");\ntry {\n  await promiseAll([Promise.resolve(1), Promise.reject(new Error("fail"))]);\n  throw new Error("Should have rejected");\n} catch(e) {\n  if ((e as Error).message !== "fail") throw new Error("Wrong error");\n}\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "lru-cache",
    title: "Cache LRU",
    description: "Implémentez un cache LRU (Least Recently Used) avec une capacité fixe.\n\nOpérations: get(key) et put(key, value). Quand le cache est plein, supprimez l'élément le moins récemment utilisé.",
    difficulty: "hard",
    orderIndex: 39,
    tags: ["data-structures", "classic"],
    templateC: '// Simplifié en C\n#define CACHE_SIZE 3\nint cache_keys[CACHE_SIZE];\nint cache_vals[CACHE_SIZE];\nint cache_count = 0;\n\nvoid cache_put(int key, int val) {\n    // Votre code ici\n}\n\nint cache_get(int key) {\n    // Retourne -1 si non trouvé\n    return -1;\n}',
    templatePython: 'class LRUCache:\n    def __init__(self, capacity: int):\n        # Votre code ici\n        pass\n\n    def get(self, key: int) -> int:\n        """Retourne -1 si non trouvé"""\n        pass\n\n    def put(self, key: int, value: int) -> None:\n        pass',
    templateTypescript: 'export class LRUCache {\n  constructor(private capacity: number) {}\n\n  get(key: number): number {\n    // Retourne -1 si non trouvé\n    return -1;\n  }\n\n  put(key: number, value: number): void {\n    // Votre code ici\n  }\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    cache_put(1, 10);\n    cache_put(2, 20);\n    assert(cache_get(1) == 10);\n    cache_put(3, 30);\n    cache_put(4, 40); // Evicts 2\n    assert(cache_get(2) == -1);\n    assert(cache_get(3) == 30);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'c = LRUCache(2)\nc.put(1, 1)\nc.put(2, 2)\nassert c.get(1) == 1\nc.put(3, 3)  # evicts 2\nassert c.get(2) == -1\nassert c.get(3) == 3\nc.put(4, 4)  # evicts 1\nassert c.get(1) == -1\nassert c.get(4) == 4\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { LRUCache } from "./solution";\nconst c = new LRUCache(2);\nc.put(1, 1); c.put(2, 2);\nif (c.get(1) !== 1) throw new Error("Failed");\nc.put(3, 3);\nif (c.get(2) !== -1) throw new Error("Should be evicted");\nif (c.get(3) !== 3) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "event-emitter",
    title: "Event Emitter",
    description: "Implémentez un système d'événements simple avec on(event, callback), emit(event, ...args) et off(event, callback).",
    difficulty: "hard",
    orderIndex: 40,
    tags: ["design-patterns", "functions"],
    templateC: '// Simplifié en C\n#include <stdio.h>\ntypedef void (*Callback)(int);\n#define MAX_LISTENERS 10\n\ntypedef struct {\n    Callback listeners[MAX_LISTENERS];\n    int count;\n} EventEmitter;\n\nvoid emitter_init(EventEmitter *e) { e->count = 0; }\nvoid emitter_on(EventEmitter *e, Callback cb) { /* Votre code */ }\nvoid emitter_emit(EventEmitter *e, int data) { /* Votre code */ }',
    templatePython: 'from typing import Callable, Any\n\nclass EventEmitter:\n    def __init__(self):\n        pass\n\n    def on(self, event: str, callback: Callable) -> None:\n        pass\n\n    def emit(self, event: str, *args: Any) -> None:\n        pass\n\n    def off(self, event: str, callback: Callable) -> None:\n        pass',
    templateTypescript: 'export class EventEmitter {\n  on(event: string, callback: (...args: any[]) => void): void {}\n  emit(event: string, ...args: any[]): void {}\n  off(event: string, callback: (...args: any[]) => void): void {}\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint last_value = 0;\nvoid handler(int v) { last_value = v; }\n\nint main() {\n    EventEmitter e;\n    emitter_init(&e);\n    emitter_on(&e, handler);\n    emitter_emit(&e, 42);\n    assert(last_value == 42);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'results = []\ndef handler(x):\n    results.append(x)\n\nee = EventEmitter()\nee.on("data", handler)\nee.emit("data", 1)\nee.emit("data", 2)\nassert results == [1, 2]\nee.off("data", handler)\nee.emit("data", 3)\nassert results == [1, 2]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { EventEmitter } from "./solution";\nconst results: number[] = [];\nconst handler = (x: number) => results.push(x);\nconst ee = new EventEmitter();\nee.on("data", handler);\nee.emit("data", 1);\nee.emit("data", 2);\nif (JSON.stringify(results) !== "[1,2]") throw new Error("Failed");\nee.off("data", handler);\nee.emit("data", 3);\nif (JSON.stringify(results) !== "[1,2]") throw new Error("Off failed");\nconsole.log("ALL TESTS PASSED");',
  },
  // === ADVANCED (41-50) ===
  {
    slug: "curry",
    title: "Currying",
    description: "Implémentez une fonction curry qui transforme une fonction prenant plusieurs arguments en une séquence de fonctions prenant chacune un seul argument.",
    difficulty: "hard",
    orderIndex: 41,
    tags: ["functions", "functional"],
    templateC: '// Simplifié: fonction qui additionne 3 nombres via currying\ntypedef int (*AddOne)(int);\ntypedef AddOne (*AddTwo)(int);\n\n// Pas facilement faisable en C\nint add_three(int a, int b, int c) { return a + b + c; }',
    templatePython: 'from typing import Callable\n\ndef curry(func: Callable) -> Callable:\n    """Transforme func en version curried"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function curry(func: (...args: any[]) => any): (...args: any[]) => any {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    assert(add_three(1, 2, 3) == 6);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'def add(a, b, c):\n    return a + b + c\n\ncurried = curry(add)\nassert curried(1)(2)(3) == 6\nassert curried(1, 2)(3) == 6\nassert curried(1)(2, 3) == 6\nassert curried(1, 2, 3) == 6\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { curry } from "./solution";\nconst add = (a: number, b: number, c: number) => a + b + c;\nconst curried = curry(add);\nif (curried(1)(2)(3) !== 6) throw new Error("Failed 1");\nif (curried(1, 2)(3) !== 6) throw new Error("Failed 2");\nif (curried(1, 2, 3) !== 6) throw new Error("Failed 3");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "tree-traversal",
    title: "Parcours d'Arbre Binaire",
    description: "Implémentez les parcours inorder, preorder et postorder d'un arbre binaire.",
    difficulty: "hard",
    orderIndex: 42,
    tags: ["data-structures", "trees", "recursion"],
    templateC: 'typedef struct TreeNode {\n    int val;\n    struct TreeNode *left, *right;\n} TreeNode;\n\nvoid inorder(TreeNode *root, int *result, int *size) {\n    // Votre code ici\n}\nvoid preorder(TreeNode *root, int *result, int *size) {\n    // Votre code ici\n}\nvoid postorder(TreeNode *root, int *result, int *size) {\n    // Votre code ici\n}',
    templatePython: 'class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef inorder(root: TreeNode) -> list[int]:\n    pass\n\ndef preorder(root: TreeNode) -> list[int]:\n    pass\n\ndef postorder(root: TreeNode) -> list[int]:\n    pass',
    templateTypescript: 'class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val = 0, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nexport function inorder(root: TreeNode | null): number[] { return []; }\nexport function preorder(root: TreeNode | null): number[] { return []; }\nexport function postorder(root: TreeNode | null): number[] { return []; }',
    testsC: '#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nTreeNode* node(int v, TreeNode*l, TreeNode*r) {\n    TreeNode*n=malloc(sizeof(TreeNode));\n    n->val=v;n->left=l;n->right=r;return n;\n}\n\nint main() {\n    TreeNode *root = node(1, node(2, node(4,NULL,NULL), node(5,NULL,NULL)), node(3,NULL,NULL));\n    int res[10]; int sz=0;\n    inorder(root, res, &sz);\n    assert(sz==5 && res[0]==4 && res[1]==2 && res[2]==5 && res[3]==1 && res[4]==3);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))\nassert inorder(root) == [4, 2, 5, 1, 3]\nassert preorder(root) == [1, 2, 4, 5, 3]\nassert postorder(root) == [4, 5, 2, 3, 1]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { inorder, preorder, postorder } from "./solution";\nconst root = new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3));\nif (JSON.stringify(inorder(root)) !== "[4,2,5,1,3]") throw new Error("Inorder failed");\nif (JSON.stringify(preorder(root)) !== "[1,2,4,5,3]") throw new Error("Preorder failed");\nif (JSON.stringify(postorder(root)) !== "[4,5,2,3,1]") throw new Error("Postorder failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "graph-bfs",
    title: "BFS sur Graphe",
    description: "Implémentez un parcours en largeur (BFS) sur un graphe représenté comme liste d'adjacence.\n\nRetournez l'ordre de visite des noeuds.",
    difficulty: "hard",
    orderIndex: 43,
    tags: ["algorithms", "graphs"],
    templateC: '#include <stdbool.h>\n\nvoid bfs(int adj[][10], int sizes[], int n, int start, int *result, int *resultSize) {\n    // Votre code ici\n}',
    templatePython: 'def bfs(graph: dict[int, list[int]], start: int) -> list[int]:\n    """BFS à partir de start, retourne l\'ordre de visite"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function bfs(graph: Record<number, number[]>, start: number): number[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int adj[4][10] = {{1,2},{0,3},{0,3},{1,2}};\n    int sizes[] = {2,2,2,2};\n    int result[10]; int sz=0;\n    bfs(adj, sizes, 4, 0, result, &sz);\n    assert(sz==4 && result[0]==0);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'g = {0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2]}\nresult = bfs(g, 0)\nassert result[0] == 0\nassert set(result) == {0, 1, 2, 3}\nassert len(result) == 4\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { bfs } from "./solution";\nconst g = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2] };\nconst r = bfs(g, 0);\nif (r[0] !== 0) throw new Error("Should start at 0");\nif (r.length !== 4) throw new Error("Should visit all");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "flatten-object",
    title: "Aplatir un Objet",
    description: "Écrivez une fonction qui aplatit un objet imbriqué en utilisant des clés avec notation pointée.\n\nExemple: {a: {b: 1, c: {d: 2}}} → {\"a.b\": 1, \"a.c.d\": 2}",
    difficulty: "hard",
    orderIndex: 44,
    tags: ["data-structures", "recursion"],
    templateC: '// Simplifié en C\n#include <stdio.h>\nint main() { printf("ALL TESTS PASSED\\n"); return 0; }',
    templatePython: 'def flatten_object(obj: dict, prefix: str = "") -> dict:\n    """Aplatit un objet avec notation pointée"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function flattenObject(obj: Record<string, any>, prefix = ""): Record<string, any> {\n  // Votre code ici\n}',
    testsC: '',
    testsPython: 'assert flatten_object({"a": {"b": 1, "c": {"d": 2}}}) == {"a.b": 1, "a.c.d": 2}\nassert flatten_object({"x": 1}) == {"x": 1}\nassert flatten_object({}) == {}\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { flattenObject } from "./solution";\nconst r = flattenObject({ a: { b: 1, c: { d: 2 } } });\nif (r["a.b"] !== 1) throw new Error("Failed a.b");\nif (r["a.c.d"] !== 2) throw new Error("Failed a.c.d");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "chunk-array",
    title: "Découper un Tableau",
    description: "Écrivez une fonction qui découpe un tableau en sous-tableaux de taille n.\n\nExemple: chunk([1,2,3,4,5], 2) → [[1,2],[3,4],[5]]",
    difficulty: "easy",
    orderIndex: 45,
    tags: ["arrays", "functions"],
    templateC: '// Retourne le nombre de chunks\nint chunk(int arr[], int size, int chunkSize, int result[][100]) {\n    return 0;\n}',
    templatePython: 'def chunk(arr: list, n: int) -> list[list]:\n    """Découpe arr en sous-tableaux de taille n"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function chunk<T>(arr: T[], n: number): T[][] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int arr[] = {1,2,3,4,5};\n    int result[10][100];\n    int n = chunk(arr, 5, 2, result);\n    assert(n == 3);\n    assert(result[0][0]==1 && result[0][1]==2);\n    assert(result[2][0]==5);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert chunk([1,2,3,4,5], 2) == [[1,2],[3,4],[5]]\nassert chunk([1,2,3], 1) == [[1],[2],[3]]\nassert chunk([], 3) == []\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { chunk } from "./solution";\nif (JSON.stringify(chunk([1,2,3,4,5], 2)) !== "[[1,2],[3,4],[5]]") throw new Error("Failed");\nif (JSON.stringify(chunk([], 3)) !== "[]") throw new Error("Failed empty");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "range",
    title: "Fonction Range",
    description: "Implémentez une fonction range similaire à celle de Python.\n\nrange(stop), range(start, stop), range(start, stop, step)",
    difficulty: "easy",
    orderIndex: 46,
    tags: ["functions", "arrays"],
    templateC: 'int range(int start, int stop, int step, int *result) {\n    // Remplit result et retourne la taille\n    return 0;\n}',
    templatePython: 'def my_range(*args) -> list[int]:\n    """Implémente range(stop), range(start,stop), range(start,stop,step)"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function range(startOrStop: number, stop?: number, step?: number): number[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int r[100]; int n;\n    n = range(0, 5, 1, r);\n    assert(n==5 && r[0]==0 && r[4]==4);\n    n = range(0, 10, 2, r);\n    assert(n==5 && r[0]==0 && r[4]==8);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert my_range(5) == [0,1,2,3,4]\nassert my_range(2, 5) == [2,3,4]\nassert my_range(0, 10, 2) == [0,2,4,6,8]\nassert my_range(5, 0, -1) == [5,4,3,2,1]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { range } from "./solution";\nif (JSON.stringify(range(5)) !== "[0,1,2,3,4]") throw new Error("Failed range(5)");\nif (JSON.stringify(range(2, 5)) !== "[2,3,4]") throw new Error("Failed range(2,5)");\nif (JSON.stringify(range(0, 10, 2)) !== "[0,2,4,6,8]") throw new Error("Failed range(0,10,2)");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "group-by",
    title: "Group By",
    description: "Implémentez une fonction groupBy qui groupe les éléments d'un tableau selon une fonction clé.",
    difficulty: "medium",
    orderIndex: 47,
    tags: ["functions", "data-structures"],
    templateC: '// Simplifié en C\n#include <stdio.h>\nint main() { printf("ALL TESTS PASSED\\n"); return 0; }',
    templatePython: 'from typing import Callable\n\ndef group_by(arr: list, key_fn: Callable) -> dict:\n    """Groupe les éléments par la clé retournée par key_fn"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function groupBy<T>(arr: T[], keyFn: (item: T) => string): Record<string, T[]> {\n  // Votre code ici\n}',
    testsC: '',
    testsPython: 'r = group_by([1,2,3,4,5,6], lambda x: "even" if x%2==0 else "odd")\nassert r == {"odd": [1,3,5], "even": [2,4,6]}\nr2 = group_by(["hi", "hey", "bye"], lambda x: x[0])\nassert r2 == {"h": ["hi", "hey"], "b": ["bye"]}\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { groupBy } from "./solution";\nconst r = groupBy([1,2,3,4,5,6], (x) => x % 2 === 0 ? "even" : "odd");\nif (JSON.stringify(r["odd"]) !== "[1,3,5]") throw new Error("Failed odd");\nif (JSON.stringify(r["even"]) !== "[2,4,6]") throw new Error("Failed even");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "pipe",
    title: "Fonction Pipe",
    description: "Implémentez une fonction pipe qui compose des fonctions de gauche à droite.\n\npipe(f, g, h)(x) = h(g(f(x)))",
    difficulty: "medium",
    orderIndex: 48,
    tags: ["functions", "functional"],
    templateC: '// Simplifié en C\ntypedef int (*IntFn)(int);\n\nint pipe2(IntFn f, IntFn g, int x) {\n    // Votre code ici\n    return 0;\n}',
    templatePython: 'from typing import Callable\n\ndef pipe(*fns: Callable) -> Callable:\n    """Compose les fonctions de gauche à droite"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function pipe(...fns: ((...args: any[]) => any)[]): (...args: any[]) => any {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint double_it(int x) { return x * 2; }\nint add_one(int x) { return x + 1; }\n\nint main() {\n    assert(pipe2(double_it, add_one, 5) == 11);\n    assert(pipe2(add_one, double_it, 5) == 12);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'double = lambda x: x * 2\nadd1 = lambda x: x + 1\n\np = pipe(double, add1)\nassert p(5) == 11\n\np2 = pipe(add1, double)\nassert p2(5) == 12\n\np3 = pipe(str.upper, lambda s: s + "!")\nassert p3("hello") == "HELLO!"\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { pipe } from "./solution";\nconst double2 = (x: number) => x * 2;\nconst add1 = (x: number) => x + 1;\nif (pipe(double2, add1)(5) !== 11) throw new Error("Failed");\nif (pipe(add1, double2)(5) !== 12) throw new Error("Failed");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "intersection",
    title: "Intersection de Tableaux",
    description: "Trouvez les éléments communs entre deux tableaux (sans doublons).",
    difficulty: "easy",
    orderIndex: 49,
    tags: ["arrays", "data-structures"],
    templateC: 'int intersection(int a[], int sizeA, int b[], int sizeB, int result[]) {\n    // Retourne la taille du résultat\n    return 0;\n}',
    templatePython: 'def intersection(a: list[int], b: list[int]) -> list[int]:\n    """Retourne les éléments communs (sans doublons)"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function intersection(a: number[], b: number[]): number[] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a[] = {1,2,3,4};\n    int b[] = {3,4,5,6};\n    int r[10];\n    int n = intersection(a, 4, b, 4, r);\n    assert(n == 2);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'r = intersection([1,2,3,4], [3,4,5,6])\nassert sorted(r) == [3,4]\nassert intersection([1,2], [3,4]) == []\nassert sorted(intersection([1,1,2], [1,1,3])) == [1]\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { intersection } from "./solution";\nconst r = intersection([1,2,3,4], [3,4,5,6]);\nif (r.sort().join(",") !== "3,4") throw new Error("Failed");\nif (intersection([1,2], [3,4]).length !== 0) throw new Error("Failed empty");\nconsole.log("ALL TESTS PASSED");',
  },
  {
    slug: "zip",
    title: "Fonction Zip",
    description: "Implémentez une fonction zip qui combine deux tableaux élément par élément.\n\nExemple: zip([1,2,3], ['a','b','c']) → [[1,'a'],[2,'b'],[3,'c']]\nTronquez au plus court tableau.",
    difficulty: "easy",
    orderIndex: 50,
    tags: ["arrays", "functions"],
    templateC: 'int zip(int a[], int sizeA, int b[], int sizeB, int result[][2]) {\n    // Retourne le nombre de paires\n    return 0;\n}',
    templatePython: 'def my_zip(a: list, b: list) -> list[list]:\n    """Combine deux listes élément par élément"""\n    # Votre code ici\n    pass',
    templateTypescript: 'export function zip<A, B>(a: A[], b: B[]): [A, B][] {\n  // Votre code ici\n}',
    testsC: '#include <assert.h>\n#include <stdio.h>\n\nint main() {\n    int a[] = {1,2,3};\n    int b[] = {4,5,6};\n    int r[10][2];\n    int n = zip(a, 3, b, 3, r);\n    assert(n==3 && r[0][0]==1 && r[0][1]==4 && r[2][0]==3 && r[2][1]==6);\n    printf("ALL TESTS PASSED\\n");\n    return 0;\n}',
    testsPython: 'assert my_zip([1,2,3], ["a","b","c"]) == [[1,"a"],[2,"b"],[3,"c"]]\nassert my_zip([1,2], [3,4,5]) == [[1,3],[2,4]]\nassert my_zip([], [1]) == []\nprint("ALL TESTS PASSED")',
    testsTypescript: 'import { zip } from "./solution";\nif (JSON.stringify(zip([1,2,3], ["a","b","c"])) !== \'[[1,"a"],[2,"b"],[3,"c"]]\') throw new Error("Failed");\nif (JSON.stringify(zip([1,2], [3,4,5])) !== "[[1,3],[2,4]]") throw new Error("Failed short");\nconsole.log("ALL TESTS PASSED");',
  },
];

async function seed() {
  logger.info("Seeding exercises...");

  for (const ex of exerciseData) {
    await db
      .insert(exercises)
      .values(ex as any)
      .onConflictDoNothing();
  }

  logger.info(`Seeded ${exerciseData.length} exercises`);
}

seed()
  .then(() => process.exit(0))
  .catch((err) => {
    logger.error(err);
    process.exit(1);
  });
